---
layout: post
title: "Deep Dive Into the Twitter Algorithm"
date: 2025-05-14
---
Wherein we deep dive into the open-sourced X algorithm...

# **Deconstructing the Twitter Recommendation Algorithm: A Deep Dive for Data Science Software Engineers**

**I. Executive Summary**

The Twitter (now X) recommendation algorithm represents a highly sophisticated, multi-stage pipeline engineered to deliver personalized content at an immense scale. Its fundamental objective is to maximize user engagement and retention by curating relevant tweets and other content across diverse platform surfaces, including the "For You" timeline, Search, Explore, and Notifications.1 This system exemplifies the intricate integration of advanced machine learning models within a robust, real-time distributed architecture. The foundational architectural principles include a microservices paradigm, extensive reliance on custom Scala frameworks, and specialized data systems designed for real-time processing and efficient feature serving.

**II. Architectural Foundations: The Engineering Landscape**

The Twitter recommendation algorithm is constructed upon a distributed microservices architecture, primarily utilizing Scala and Java for its core services. Python is employed for scripting and machine learning model development, while Rust is strategically chosen for high-performance machine learning serving. This polyglot approach allows for optimized performance characteristics across distinct system components, leveraging the strengths of each language.1

**High-level System Architecture and Component Interdependencies**

The twitter/the-algorithm repository reveals a modular design, with numerous directories corresponding to discrete services and components.1 This modularity is paramount for managing the inherent complexity of such a large-scale system, enabling independent scaling and deployment of individual services.3 Key architectural components include tweetypie, which serves as the core Tweet data service responsible for reading and writing tweet data; unified-user-actions, providing a real-time stream of user actions; and user-signal-service, a centralized platform for retrieving explicit (e.g., likes, replies) and implicit (e.g., profile visits, tweet clicks) user signals. These are complemented by various machine learning models and software frameworks that collectively form the recommendation engine.1 The system exhibits a consumption-heavy profile, characterized by significantly more read operations (approximately 300,000 queries per second) compared to write operations (around 6,000 requests per second), which necessitates highly optimized read paths and sophisticated caching strategies.4

**The Pivotal Role of Home Mixer as the Central Timeline Service**

Home Mixer is explicitly designated as the primary service for constructing and serving Twitter's Home Timelines. This includes the highly personalized "For You" feed, the "Following" feed (reverse chronological tweets from followed accounts), and "Lists" feeds.5 Functioning as the central orchestrator, Home Mixer integrates diverse candidate sources, applies scoring functions, incorporates heuristics, and filters content to compile the final user timeline.5 The "For You" timeline, a central focus of the open-sourced algorithm, typically comprises a balanced mix of in-network content (from accounts a user follows) and out-of-network content (recommended content from accounts not followed), often maintaining an average 50/50 split.7

**Product Mixer: Twitter's Custom Scala Framework for Content Feeds**

Home Mixer is built upon Product Mixer, a custom Scala framework specifically engineered for the creation and management of content feeds.5 Services developed using Product Mixer are structured around a hierarchy of "Pipelines" – Product Pipelines, Mixer Pipelines, Recommendation Pipelines, and Candidate Pipelines. This pipeline architecture transparently segments execution into well-defined, structured steps, which is a fundamental abstraction for managing the complexity of content aggregation and ranking within the system.5 This design fosters modularity and clear data flow, essential for a system of this scale.

**Overview of Primary Programming Languages and Their Strategic Use**

Scala and Java are the predominant programming languages within the repository, accounting for 63.0% and 21.9% of the codebase, respectively.1 This reflects Twitter's historical backend technology stack and the suitability of the JVM ecosystem for developing large-scale distributed systems. Starlark (5.8%) is utilized for configuration, while Python (3.9%) is employed for scripting, data processing, and machine learning model development where rapid iteration and extensive libraries are advantageous.1 Notably, Rust (1.8%) is used for Navi, a high-performance machine learning serving server.1 The selection of Rust for Navi underscores a deliberate pursuit of maximum performance and memory safety for critical, low-latency machine learning inference components.10 This strategic polyglotism, where different languages are chosen to optimally match their characteristics to specific service requirements, is a key architectural decision. It implies that for data science software engineers, a deep understanding of language performance characteristics and the trade-offs involved in selecting the right tool for the right task is crucial, moving beyond a monolithic language strategy. Furthermore, it necessitates robust inter-service communication protocols, such as gRPC (which Navi supports), to ensure seamless integration across diverse language runtimes.9

**Discussion of Microservices and Distributed System Design for Extreme Scalability**

The architecture employs horizontal scaling, where requests and data are distributed across multiple servers, to prevent bottlenecks and ensure high availability.3 Load balancing mechanisms, including round-robin, dynamic, and global strategies, distribute user requests evenly and direct them to the nearest data center, thereby minimizing latency.11 Data partitioning, or sharding, across different servers ensures that no single server stores all data, leading to an even distribution of workload.11 Twitter's system adopts an event-driven approach, utilizing asynchronous processing queues for tasks such as timeline updates and notifications. This design decouples services, enhancing responsiveness and system resilience.11 Data replication across multiple data centers is also a critical practice, ensuring low-latency access for a globally distributed user base and providing robust disaster recovery capabilities.11

A significant observation from this architecture is the pervasive application of the "Mixer" pattern as a core abstraction for recommendation systems. The explicit mention of Product Mixer as a custom Scala framework for building feeds 5 and Home Mixer as its primary application 5 indicates a reusable, generalized pattern for content aggregation and ranking. The "pipelines" concept within Product Mixer suggests a highly configurable and extensible architecture for combining heterogeneous candidate sources, scoring functions, and filters. This modularity allows for independent innovation and optimization within each stage of the recommendation process, which is critical for continuous improvement in a dynamic machine learning environment. This pattern emphasizes the separation of concerns, where candidate generation, feature hydration, ranking, and filtering are distinct stages orchestrated by a central mixing layer.

Another important aspect of this design is the comprehensive capture of user behavior, encompassing both explicit and implicit signals, and their real-time capture. The unified-user-actions service captures both "public actions such as favorites, retweets, replies" (explicit) and "implicit actions like bookmark, impression, video view" (implicit).13 The user-signal-service then centralizes the retrieval of these diverse signals.1 This holistic approach to capturing user interactions, both overt and subtle, forms the foundation for rich feature engineering. The emphasis on a "real-time stream" 13 indicates a critical requirement for low-latency feedback loops to continuously inform and update the machine learning models. For machine learning engineers, this highlights the necessity of a robust, real-time data infrastructure to capture the full spectrum of user interactions. Implicit signals, while potentially more challenging to interpret, often provide a much higher volume of data points, enabling more granular and continuous model training and adaptation. The real-time nature of this data capture is essential for ensuring the freshness and responsiveness of recommendations.

**III. The Recommendation Pipeline: From Raw Data to Personalized Feeds**

Twitter's recommendation pipeline is a multi-stage process that transforms billions of daily tweets into a personalized "For You" timeline. This pipeline systematically progresses through candidate generation, feature hydration, sophisticated ranking, and a final series of heuristics and filters.5

**A. Candidate Generation**

The initial phase, candidate generation, involves fetching potential tweets from various sources. The objective is to compile a pool of approximately 1,500 candidate tweets for evaluation during each user session.6

* **In-Network Source:** This constitutes the primary candidate source, focusing on delivering timely and relevant tweets from users a person follows. These tweets are initially ranked based on relevance using a logistic regression model. A crucial element in this ranking is Real Graph, a model that predicts the likelihood of engagement between two users. A higher Real Graph score increases the probability of a tweet being included in a user's feed.2 Notably, Twitter has recently phased out the Fanout Service, which was previously used for caching in-network tweets, and is in the process of redesigning the long-standing logistic regression ranking model.6  
* **Out-of-Network Sources:** Identifying relevant tweets from accounts a user does not follow is a more complex task.15 Two principal approaches are employed for this purpose:  
  * **Social Graph Analysis:** This method estimates relevance by examining engagement patterns among users a person follows or those with similar interests. It considers which tweets followed accounts have engaged with and which tweets the user has liked.6  
  * **Embedding Spaces:** This approach focuses on content similarity by generating numerical representations of user interests and tweet content.2 SimClusters is a significant embedding space utilized here, identifying communities led by influential users through a specialized matrix factorization algorithm.6  
* **Specific Candidate Sources:** The Home Mixer documentation lists Earlybird Search Index, User Tweet Entity Graph, Cr Mixer, and Follow Recommendations Service as examples of distinct candidate sources feeding into the system.5  
* **Quantitative Insights:** The "For You" timeline typically maintains a balanced composition, consisting of approximately 50% in-network tweets and 50% out-of-network tweets on average.7

The combination of in-network (direct connections, relevance via Real Graph) and out-of-network (social graph analysis, embedding spaces like SimClusters) candidate sources represents a deliberate strategy. This hybrid approach ensures that core social connections are maintained while simultaneously expanding content reach and discoverability beyond a user's immediate echo chamber. The 50/50 split observed in the "For You" timeline suggests a balanced approach to maximizing both relevance and serendipity, which are critical for user retention. This hybrid approach is a common pattern in mature recommendation systems, effectively addressing the "explore-exploit" dilemma: exploiting known preferences (in-network) while exploring new, potentially engaging content (out-of-network). For engineers, this implies the necessity of distinct, optimized retrieval mechanisms for different types of content, each with its own scaling and freshness requirements.

Furthermore, the repeated emphasis on Real Graph for in-network ranking 6 and "Social Graph Analysis" for out-of-network content 6 highlights that user-user and user-content relationships are central to candidate selection. SimClusters 6 further reinforces this by identifying communities based on follower graphs. This design indicates that the underlying data model is heavily graph-centric, enabling complex relationship inference. For data scientists, this underscores the power of graph-based features and models in recommendation systems, particularly for capturing social dynamics and implicit connections. It suggests that investment in graph databases or graph processing frameworks is likely a core infrastructure decision.

**B. Feature Engineering and Hydration**

Following candidate generation, the system proceeds to fetch a substantial number of features, approximately 6,000, which are essential for the subsequent ranking process.5

* **Categorization and Purpose of Features:** Features are broadly categorized into static, real-time, user-specific, and search context features.16  
  * **Static Features:** These are computed directly from a tweet at the time of its creation, such as the presence of a URL, cards, or quotes, and are stored within the index.16  
  * **Real-time Features:** These per-tweet features can change after the tweet has been indexed. They primarily consist of social engagements like retweet count, favorite count, reply count, and various spam signals, which are computed based on later user activities. A Signal Ingester processes multiple event streams to collect and compute these real-time features.16  
  * **User Table Features:** These are per-user features obtained from a User Table Updater that processes a stream written by the user service. This input is used to store sparse real-time user information, which is then propagated to the tweet being scored by looking up the author of the tweet.16  
  * **Search Context Features:** These features represent the context of the current searcher, including their UI language, content consumption patterns, and the current time.16  
* **The Role of Unified User Actions (UUA) and User Signal Service in Capturing User Behavior:**  
  * Unified User Actions (UUA) is described as a centralized, real-time Kafka stream of user actions. It captures both public actions (e.g., favorites, retweets, replies) and implicit actions (e.g., bookmarks, impressions, video views).13 UUA reads client-side and server-side event streams and generates a unified real-time user actions Kafka stream, which is then replicated to various data stores including HDFS, GCP Pubsub, GCP GCS, and GCP BigQuery.13  
  * The User Signal Service functions as a centralized platform designed to retrieve these explicit and implicit user signals, making them accessible for downstream models and services.1  
* **Timelines Aggregation Framework for Generating Aggregate Features:**  
  * This framework, located within timelines/data\_processing/ml\_util/aggregation\_framework, enables the flexible computation of aggregate (counting) features in both batch and real-time.17  
  * It is capable of capturing historical interactions between arbitrary entities, such as a user's past engagement history with various types of tweets (e.g., photo, video, retweets), specific authors, or in-network engagers.17  
  * The framework supports offline daily batch processing, where generated aggregate features are uploaded to Manhattan for online hydration. Additionally, it supports online real-time aggregation of DataRecords through Storm, with a backing memcache that can be queried for real-time aggregate features. These features are critically used by the Home Timeline heavy ranker and other recommendation systems.17

The sheer volume of features (approximately 6,000) and their categorization into static, real-time, and user-table features points to a highly granular and comprehensive understanding of content and user context. The Timelines Aggregation Framework's capability to compute features in both batch (historical) and real-time modes is crucial. This multi-temporal approach allows machine learning models to learn from long-term user preferences while also adapting to immediate, fresh signals. This design choice highlights that feature engineering is not a one-off task but an ongoing, complex process. A robust feature store and a real-time feature computation pipeline are therefore essential for high-performing, adaptive recommendation models. The combination of batch and real-time aggregation suggests an architecture akin to Lambda or Kappa architectures for feature generation.18

Furthermore, the role of UUA as a "centralized, real-time stream of user actions" 13 that is consumed by machine learning teams 13 and directly feeds into the User Signal Service and Timelines Aggregation Framework is fundamental. This architectural choice demonstrates that the underlying data architecture for machine learning is event-driven, heavily leveraging Apache Kafka.13 This ensures low-latency data availability for feature hydration and model training, which is critical for real-time recommendations. This confirms that for large-scale, real-time machine learning systems, a streaming data platform like Kafka is indispensable. It enables continuous feedback loops, allowing models to react quickly to changing user behavior and content trends.

**C. Ranking with the Heavy Ranker**

The "Heavy Ranker" is the core machine learning model responsible for scoring and ranking the generated candidate tweets.5 This model evaluates approximately 1,500 candidates for each user session.6

* **In-depth Analysis of the Neural Network Architecture and its Parameter Scale:** The ranking process is accomplished using a neural network comprising approximately 48 million parameters.6 This scale indicates a deep learning approach, where the network is continuously trained on tweet interactions to optimize for positive engagements.6 The model incorporates thousands of features to assign scores based on the predicted probability of user engagement with each tweet.6  
* **Influence of Twitter Blue Subscriptions and Account Credibility on Ranking Scores:** Tweets from Twitter Blue subscribers reportedly receive a significant boost in ranking. Specifically, their tweets can achieve a 2x higher score among non-followers and a 4x higher score among followers compared to unverified posts.7 Account credibility, quantified by a Tweepcred score (a reputation metric), verification status, follower-to-following ratio, consistent account activity, and absence of prior bans, also substantially influences ranking.22 Accounts with a tweepcred score below 65 may have a limited number of their tweets considered by the ranking algorithm.2  
* **Recency Decay and Content Type Prioritization:** Recency is a paramount ranking signal, with fresh content being prioritized.15 Tweets are subject to a relevancy half-life of 360 minutes (6 hours), meaning their score decreases by 50% every 6 hours.2 Content incorporating rich media, such as images, videos, GIFs, or polls, generally exhibits superior performance and receives higher scores due to its propensity to drive increased engagement.15 Tweets containing links that display images and videos, especially those utilizing Twitter Card markup, may receive an additional advantage in ranking.28

The following table, derived from the algorithm's internal weighting, illustrates how different user actions are valued by the Heavy Ranker when determining a tweet's relevance score. These weights represent the relative importance assigned to each predicted user action, with Retweet serving as a baseline unit.

**Heavy Ranker Engagement Weighting**

| User Action | Relative Weight (vs. Retweet=1) | Sentiment |
| :---- | :---- | :---- |
| Like the post | 0.5 | Positive |
| Retweet the post | 1 | Positive |
| Reply to the post | 13.5 | Positive |
| Open the post author's profile and like or reply to a post | 12 | Positive |
| Watch at least half of the video | 0.005 | Positive |
| Reply to the post and the tweet author engages with the reply | 75 | Positive |
| Click into the conversation of the post and engage with a reply | 11 | Positive |
| Click into the conversation of the post and stay for ≥ 2 mins | 10 | Positive |
| Request "show less often"/block/mute the post author | \-74 | Negative |
| Report the Tweet | \-369 | Negative |

2

The extremely high weights assigned to replies (13.5x a retweet) and particularly to replies that elicit a response from the tweet author (75x a retweet) reveal a strong algorithmic bias towards fostering genuine conversations over passive consumption (likes, retweets). This indicates that the algorithm is not merely focused on displaying popular content, but rather content that actively generates dialogue. This design choice suggests a strategic reinforcement towards building a more interactive community on the platform, moving beyond a simple broadcast medium. For engineers, this implies that features related to conversation depth, reply quality, and author responsiveness would be highly impactful in model development. It also suggests that the platform values "stickiness" derived from interaction more than just impressions.

The explicit boost for Twitter Blue subscribers and the influence of Tweepcred (a reputation score based on network structure and user behavior) indicate that the algorithm is not purely content- or engagement-driven. It incorporates a layer of "authority" or "paid privilege." This has significant implications for content creators and platform dynamics, suggesting a tiered visibility system where paid status or established credibility can bypass some of the organic ranking challenges. For engineers, this means that these "meta-features" (subscription status, reputation scores) are directly integrated into the ranking model, potentially as high-weight features or even as post-ranking multipliers.

The neural network being "continuously trained on Tweet interactions" 6 and the emphasis on real-time features 16 and recency decay 2 highlight a system designed for rapid adaptation. The half-life of 6 hours for tweet relevance 2 indicates that the algorithm is constantly re-evaluating content freshness and user interest. This necessitates a robust MLOps pipeline for continuous integration and deployment of models, rapid feature updates, and efficient inference at scale. It implies that static, batch-trained models would quickly become stale; the system must be able to ingest new data, retrain, and deploy updated models with minimal latency to maintain relevance.

**D. Core Machine Learning Models and Services**

Beyond the "Heavy Ranker," several specialized machine learning models and services contribute critical signals and embeddings to the recommendation pipeline.

* **Real Graph:** This is a machine learning model, specifically a gradient boosting tree classifier, designed to predict the likelihood of one Twitter user interacting with another.20 It constructs a labeled dataset from a graph of Twitter users, incorporating various features such as tweet counts, follows, favorites, and other metrics related to user behavior.31 Real Graph collects both visible interactions (e.g., retweets, favorites, mentions, messages) and implicit interactions (e.g., tweet clicks, profile visits), capturing their frequency, intensity, and recency.32 This model is utilized to compute improved user recommendations, enhance the relevance of user search results, and effectively differentiate between strong and weak social ties.32 Real Graph is fundamental for understanding social tie strength, which is a critical signal for ranking in-network content and for social graph analysis in out-of-network candidate sourcing.6  
* **SimClusters:** This component serves as a general-purpose representation layer based on overlapping communities. It captures users and heterogeneous content as sparse, interpretable vectors to support a multitude of recommendation tasks.20 SimClusters discovers approximately 145,000 communities, which are updated every three weeks. These communities are anchored by influential users and are identified using a custom matrix factorization algorithm applied to the Producer-Producer similarity graph.2 The process generates "Known For" embeddings (representing a producer's affiliation with a community) and "Interested In" embeddings (representing a consumer's interest in communities).33 SimClusters enables content similarity assessment and community-based recommendations, which are crucial for expanding a user's feed beyond direct connections and for identifying trending content within specific niches.2  
* **TwHIN (Twitter Heterogeneous Information Network):** TwHIN provides dense knowledge graph embeddings for Users and Tweets.1 It is trained on 7 billion tweets across over 100 languages, utilizing both text-based self-supervision and a social objective derived from rich social engagements (Favorites, Replies, Retweets, Follows) within the TwHIN.34 This model represents various entity types (User, Tweet, Advertiser, Ad) and relation types (Follow, Authors, Favorites, Replies, Retweets, Promotes, Clicks).8 It is specifically designed to capture social signals, content engagement signals, and advertisement engagements.8 TwHIN provides a richer, more comprehensive understanding of user and tweet relationships by integrating diverse interaction types into a unified embedding space, thereby overcoming the limitations of text-only models.34 It serves as a powerful feature source for the Heavy Ranker.  
* **Tweepcred:** This is a PageRank-based algorithm that calculates the influence and reputation of Twitter users based on their interactions, such as mentions and retweets.1 It considers various factors, including the follower-to-following ratio, account age, total number of followers and followings, device usage, and safety status (e.g., restricted, suspended, verified).24 Tweepcred provides a "quality stamp" for accounts, influencing their visibility and ensuring that content from credible and influential accounts is seen by a wider audience.22 It is a key factor in algorithmic prioritization.  
* **Trust and Safety Models:** This suite of models includes pNSFWMedia (detects NSFW images), pNSFWText (detects NSFW text/sexual topics), pToxicity (detects toxic content like insults), and pAbuse (detects abusive content such as hate speech or targeted harassment).1 These models are critical for content moderation, actively filtering out low-quality or harmful content.15 They are integrated into the ranking and filtering pipeline to ensure a safe and positive user experience, preventing the amplification of harmful content and maintaining platform integrity.20  
* **Navi: High-Performance ML Model Serving in Rust:** Navi is a high-performance, versatile machine learning serving server implemented in Rust. It is specifically tailored for production usage within Twitter's technology stack.1 Navi offers gRPC API compatibility with TensorFlow Serving, enabling seamless integration with existing clients. Its pluggable architecture supports various machine learning runtimes, including out-of-the-box support for TensorFlow and Onnx Runtime, with PyTorch in an experimental state.9 Navi addresses the critical need for low-latency inference for complex machine learning models like the Heavy Ranker. Its implementation in Rust underscores the pursuit of maximum performance and efficiency for real-time scoring, directly impacting user experience and system throughput.10

The presence of SimClusters (community embeddings), TwHIN (heterogeneous network embeddings), and Real Graph (user interaction likelihood) indicates that Twitter employs multiple, specialized embedding spaces. Each of these components captures different facets of user and content relationships, such as community dynamics, interaction patterns, content similarity, and social graph structure. These are not redundant but rather complementary, providing a rich, high-dimensional representation for the Heavy Ranker. This design choice highlights that a single embedding space is often insufficient for complex recommendation tasks. Engineers should consider building a suite of specialized embeddings that capture different types of signals (e.g., semantic, social, temporal) to provide comprehensive context to ranking models. This also implies a significant investment in distributed embedding computation and serving infrastructure.

The trust-and-safety-models are listed as core "Model" components 1 and are explicitly used for filtering during the ranking process.20 This demonstrates that content moderation is not merely a separate, post-hoc layer but an intrinsic part of the recommendation pipeline. Negative feedback signals (mute, block, report) are heavily weighted negatively in the ranking.20 This illustrates a proactive approach to content moderation, where "safety by design" is embedded within the algorithm itself. Content perceived as harmful or low-quality is not just removed but actively de-prioritized or filtered out *before* it reaches the user's timeline. For machine learning engineers, this implies that trust and safety signals are critical features in the ranking model's objective function, balancing engagement with platform health.

The presence of Tweepcred, a PageRank-based influence system 35, as a distinct model component 1 that directly impacts ranking 22 signifies that the algorithm considers not just *what* is said or engaged with, but *who* is saying it. Reputation, derived from network structure and user behavior, serves as a powerful signal. This is a key differentiator from purely content-based or engagement-based systems. It suggests that a user's standing within the network can significantly amplify or suppress their content's reach. For engineers, developing robust and fair reputation systems (and mitigating potential biases) is a complex but high-impact area in social media recommendation.

**E. Heuristics and Filters**

Following the ranking stage, a series of heuristics and filters are applied to ensure that the final feed presented to the user is balanced, diverse, and safe.5

* **Visibility Filtering:** This mechanism excludes tweets based on user preferences, such as content from blocked or muted accounts, or due to legal compliance requirements.5 It can also involve restricting abuse-prone hashtags and search results.37  
* **Author Diversity:** This heuristic prevents the display of an excessive number of consecutive tweets from a single author, ensuring variety and preventing feed monotony.5  
* **Content Balance:** The algorithm actively maintains an equitable mix of in-network and out-of-network tweets in the user's feed.5  
* **Feedback-based Fatigue:** This filter dynamically reduces the scores of tweets that have received negative feedback from the user, such as actions like "show less often," blocking, or muting.5 Recent negative feedback is weighted more heavily and can lead to immediate filtering of content.8  
* **Social Proof:** This filter specifically excludes out-of-network tweets that lack a sufficient connection within the user's network. For instance, it might require a second-degree connection, meaning someone the user follows must have engaged with the tweet or followed its author. This acts as a quality safeguard for recommended content.6  
* **Conversations:** The system threads replies with their original tweets to provide necessary context, enhancing readability and understanding of ongoing discussions.6  
* **Edited Tweets:** When a tweet is edited, the system updates stale content with the revised versions, ensuring users see the most current information.6

While the Heavy Ranker primarily optimizes for engagement, these heuristics and filters address crucial aspects of user experience and platform health. They tackle issues such as feed monotony (Author Diversity), content relevance (Visibility Filtering), and quality control (Social Proof, Feedback-based Fatigue). These are not merely minor adjustments but essential components that shape the final user experience, preventing "algorithmic monoculture" or exposure to unwanted content. This highlights that a powerful ranking model alone is insufficient. A robust set of post-ranking rules and filters is necessary to ensure diversity, prevent negative user experiences (e.g., too many tweets from one person, unwanted content), and align with platform policies. This often involves a delicate balance between algorithmic optimization and human-defined rules.

The explicit mention of "Feedback-based Fatigue" 5 and the significant negative weights for "show less often," block, mute, and report actions 20 demonstrate that user dissatisfaction is a direct input to the algorithm. This goes beyond simply not engaging; it actively suppresses content the user dislikes. This is a crucial aspect of user-centric design in recommendation systems, allowing users to "train" their own feed by providing negative signals. For engineers, it means building reliable mechanisms for capturing and propagating negative feedback signals in real-time and ensuring these signals have a strong, immediate impact on ranking. This is a key lever for improving user satisfaction and combating unwanted content.

**IV. Data Infrastructure and Real-time Processing at Scale**

Twitter's recommendation system operates at an unprecedented scale, necessitating a robust and highly performant data infrastructure capable of real-time ingestion, processing, and serving.

**Leveraging Apache Kafka for Real-time Data Ingestion, Streaming, and ML Logging Pipelines**

Apache Kafka plays a pivotal role in Twitter's data pipeline, enabling the real-time ingestion and streaming of massive volumes of tweets and user interactions.19 Its distributed architecture is fundamental to ensuring scalability and fault tolerance, allowing Twitter to manage extremely high data throughput.19 Twitter extensively utilizes Kafka Streams for real-time analysis and processing of tweet streams, which is critical for identifying trending topics, detecting anomalies, and extracting valuable insights with minimal latency.19 A significant application of Kafka is in the machine learning logging pipeline for the home timeline prediction system. This pipeline transitioned from a seven-day batch processing model to a one-day streaming model using Kafka and Kafka Streams, resulting in improved model quality and substantial savings in engineering time.38 User login events, tweet events, user interaction events (such as likes, retweets, and follows), and even the recommendations themselves are all produced and consumed as messages within Kafka for real-time processing and delivery.19

**The Role of Apache Storm in Real-time Stream Processing for Analytics and Feature Generation**

Apache Storm is employed for real-time stream processing, particularly for tasks that demand fast, scalable, reliable, and fault-tolerant continuous processing of tweets.39 It is applied in critical areas such as opinion mining (sentiment analysis) and real-time analytics for trending hashtags.39 The Timelines Aggregation Framework, a key component for feature generation, supports real-time aggregation of DataRecords through Storm, with a backing memcache for online feature hydration.17 Storm complements Kafka by providing a robust framework for complex, continuous computations on streaming data, which is essential for generating the real-time features and analytics that directly feed into the recommendation models.

**Twitter's Custom Distributed Database: Manhattan, its Consistency Model, and Use Cases**

Twitter developed Manhattan, a custom-built, real-time, multi-tenant distributed key/value database. This system was designed to serve millions of queries per second with extremely low latency and high availability.41 Manhattan was created to overcome the scalability and expansion difficulties encountered with previous systems, such as Cassandra, which proved challenging to scale for Twitter's unique demands.41 Manhattan supports various consistency guarantees, allowing clients to specify stronger consistency types when required for particular operations.42 It also offers a graph-based interface for interacting with edges and is utilized for batch Hadoop importing and time series counters.41 Manhattan represents Twitter's solution to the challenges of storing and retrieving massive amounts of data with stringent real-time performance requirements. Its custom nature highlights the extreme demands of Twitter's scale, where off-the-shelf solutions may not suffice. This demonstrates that for companies operating at Twitter's scale, bespoke infrastructure is often required, driven by unique performance, consistency, and scalability demands that commercial or open-source alternatives cannot fully meet. It underscores the deep engineering expertise required to operate at such a scale, where even marginal gains in efficiency or consistency can have massive impacts.

While Twitter operates at a massive scale and employs eventual consistency for most of its systems 11, Manhattan allows clients to "set a stronger consistency guarantee" for specific operations.42 This indicates a nuanced approach to data consistency, where different parts of the system or different data types might have varying consistency requirements based on their functional needs. This is a critical lesson for distributed systems engineers: strict consistency is expensive and often unnecessary for all data. A well-designed large-scale system will apply the appropriate consistency model (e.g., eventual, strong) to different data stores or operations based on business requirements and performance trade-offs. This requires careful architectural planning and a deep understanding of distributed systems theory.

**Caching Strategies for Low-Latency Data Access**

Caching is a crucial optimization for speeding up data retrieval and significantly reducing the load on backend databases.11 User timelines, for instance, are extensively cached, often residing in a Redis cluster, with each user's timeline typically having a maximum of 800 entries.4 Frequently accessed data, including user preferences or top-K recommendations, are also cached using systems like Redis or Memcached.12 Caching is a fundamental practice for read-heavy systems like Twitter, ensuring that frequently requested content is delivered with minimal latency, which directly enhances the user experience.

**Underlying Scalability Principles: Horizontal Scaling, Sharding, and Load Balancing**

Twitter employs horizontal scaling to distribute requests across multiple servers, a foundational principle for handling large user bases.3 Load balancers, utilizing strategies such as round-robin, dynamic, and global distribution, evenly distribute user requests and direct them to the nearest data center to minimize latency.11 Data is partitioned, or sharded, across different servers to prevent any single server from storing all data, ensuring an even distribution of workload and preventing hot spots.11 These principles are standard but absolutely critical for any system operating at Twitter's scale, ensuring high availability, fault tolerance, and consistent performance under extreme load.

The transition of the machine learning logging pipeline from a 7-day batch latency to a 1-day streaming latency using Kafka Streams 38 represents a significant architectural evolution. This indicates a continuous drive towards real-time data processing for improved model freshness and responsiveness. This is not a static architecture but one that constantly adapts to performance and quality requirements. For data science software engineers, this highlights the long-term trend in large-scale machine learning systems: the move away from purely batch-oriented pipelines towards real-time streaming architectures. This necessitates expertise in stream processing frameworks (Kafka, Storm), event-driven design, and the challenges of managing data consistency and fault tolerance in real-time environments.

**V. Evaluation and Continuous Improvement Methodologies**

The Twitter algorithm is not a static entity; it continuously evolves through rigorous evaluation and iterative development. This ongoing process aims to optimize for user engagement and satisfaction while diligently mitigating any negative impacts.

**Key Performance Indicators (KPIs) Used to Measure Algorithm Effectiveness**

The algorithm is fundamentally designed to optimize for positive engagements, including Likes, Retweets, and Replies.6 A comprehensive set of key performance indicators (KPIs) is tracked to measure the algorithm's effectiveness:

* **Engagement Metrics:** These include Likes, Retweets, Replies, Clicks (on links, media, or profile), Mentions, Quote Posts, and Bookmarks.20 These metrics collectively signal content appreciation, the extent of reach, and the value generated through conversations.44  
* **Visibility Metrics:** Impressions, representing the total number of times a tweet was viewed, and Reach, indicating the unique audience exposed to tweets, are crucial for understanding overall content visibility.25  
* **Derived Metrics:** Key derived metrics include Engagement Rate (calculated as Total engagements ÷ impressions × 100\) and Click-Through Rate (Link Clicks ÷ Impressions × 100).25  
* **Growth Metrics:** The number of Followers, Follower Growth Rate, and Profile Views are tracked to assess audience expansion and account interest.43  
* **Content-Specific Metrics:** For multimedia content, Video Completion Rate is monitored, and Hashtag Performance is analyzed to gauge the effectiveness of trending topics and content discoverability.46

Twitter Analytics provides detailed insights into audience demographics and the performance of individual tweets, enabling data-driven content strategy adjustments.26

**A/B Testing Frameworks and Their Application in Iterative Algorithm Development**

A/B testing is a foundational methodology for the iterative evaluation and development of different versions of the recommendation algorithm.47 This approach allows for controlled experimentation on specific factors, such as variations in wording, message length, overall tone, the number and relevance of hashtags, the effectiveness of different images or videos when paired with tweets, and optimal posting times.49 The typical process involves setting up a Twitter Dashboard, carefully constructing controlled tweets (where only the factor under test is varied, keeping all other elements constant), scheduling their release, and meticulously tracking their performance against predefined metrics.49 A/B testing provides a controlled, data-driven approach to understand how changes to the algorithm or content strategy directly impact user behavior, thereby enabling continuous optimization and the confident rollout of new features.

**Challenges and Approaches in Evaluating Broader Algorithmic Impacts**

While recommendation algorithms typically optimize for users' *revealed preferences* (i.e., user engagement like clicks, shares, and likes), there is a recognized disparity with *stated preferences* (what users explicitly *say* they want).50 Research indicates that Twitter's engagement-based algorithm has been observed to amplify emotionally charged, out-group hostile content that users report makes them feel worse about their political out-group.50 Studies leverage observational evidence and digital traces to infer the algorithmic amplification of low-credibility content, noting that high-engagement, high-follower tweets containing low-credibility URL domains can receive amplified visibility.51 Furthermore, metrics are logged for prominent Democrat and Republican accounts to understand the differential effects of features across the political spectrum.21

This situation highlights the complex societal impact of large-scale recommendation systems. Optimizing solely for engagement can lead to unintended consequences, such as the amplification of misinformation or divisive content. This necessitates a broader perspective on algorithm evaluation, incorporating user surveys, qualitative analysis, and ethical considerations that extend beyond simple engagement metrics. This underscores the critical need for multi-objective optimization in recommendation systems. Beyond maximizing engagement, models should also consider factors such as content quality, diversity, user well-being, and adherence to ethical guidelines. This requires defining and measuring these broader objectives, potentially incorporating them directly into the loss function or as post-ranking re-rankers. It also highlights the importance of interdisciplinary collaboration, for example, with social scientists and ethicists, in the design and refinement of algorithms.

The very act of open-sourcing the algorithm 7 and the stated future developments, such as "enhanced transparency regarding safety labels" and "increased visibility into the factors influencing tweet appearances" 6, indicate a growing demand for algorithmic accountability. The logging of metrics for Elon Musk's personal experience and for prominent political accounts 21 also points to internal scrutiny and a response to external pressures regarding potential biases. This suggests a societal shift towards greater scrutiny of powerful algorithms. For engineers, this implies not only building effective models but also designing them with explainability, auditability, and fairness in mind. It signals a future where "black box" algorithms are less acceptable, and there is a growing need to articulate how algorithmic decisions are made, how biases are mitigated, and how the system aligns with broader public interest.

**VI. Conclusion and Engineering Implications**

The Twitter recommendation algorithm stands as a sophisticated engineering achievement, exemplifying the challenges and innovations inherent in large-scale machine learning and distributed systems. Its architecture, predominantly implemented in Scala and Java, and augmented by Rust for high-performance machine learning serving, demonstrates a pragmatic polyglot approach designed to optimize for specific performance characteristics. The multi-stage pipeline, encompassing candidate generation, feature hydration, and neural network-based ranking, is meticulously engineered to personalize content at scale.

Key implications for data science software engineers working on similar large-scale recommendation systems include:

* **The Transformative Power of Graph-Based Features and Embeddings:** Models such as Real Graph, SimClusters, and TwHIN are foundational, illustrating the critical role of understanding complex relationships (user-user, user-content, content-content) within a social network context. Investing in robust graph processing and embedding generation capabilities is crucial for capturing these intricate dynamics.  
* **The Imperative of Real-time Data Infrastructure:** The heavy reliance on Apache Kafka for real-time data ingestion and streaming, coupled with systems like Apache Storm for real-time aggregations, underscores the non-negotiable necessity of low-latency feedback loops for dynamic recommendation systems. The freshness of data directly correlates with the relevance and responsiveness of recommendations.  
* **Feature Engineering as a Continuous, Multi-Temporal Discipline:** The sheer volume and diverse nature of features—ranging from static and real-time to aggregate and user-specific—highlight that comprehensive feature engineering, spanning both batch and real-time computation, is paramount for achieving high model performance.  
* **Beyond Engagement: The Mandate for Multi-Objective Optimization:** While engagement remains a primary driver, the analysis reveals the critical need to incorporate broader objectives into algorithmic design. These include content quality, diversity, and user well-being, which are addressed through trust and safety models, negative feedback loops, and explicit filters. This necessitates a careful definition of success metrics that extend beyond simple clicks or likes.  
* **The "Mixer" Pattern for Scalable Orchestration:** The Product Mixer framework exemplifies a modular, pipeline-driven approach to orchestrating complex recommendation logic. This design allows for the independent development and optimization of candidate sources, rankers, and filters, fostering agility and scalability.  
* **Custom Infrastructure as a Necessity at Extreme Scale:** Twitter's development of bespoke systems like Manhattan demonstrates that for the most demanding scales, off-the-shelf solutions may not always suffice. This necessitates custom engineering solutions precisely tailored to unique performance and consistency requirements.  
* **The Growing Importance of Algorithmic Accountability and Transparency:** The open-sourcing effort and the stated focus on evaluating broader societal impacts signal an increasing demand for explainable, fair, and auditable algorithms. Engineers must consider these critical aspects from the initial design phase of any large-scale recommendation system.

The Twitter algorithm is an evolving system, constantly adapting to user behavior, content trends, and societal demands. Its open-sourced nature provides an invaluable blueprint for engineers striving to build the next generation of intelligent, scalable recommendation platforms.

#### **Fuentes citadas**

1. twitter/the-algorithm: Source code for Twitter's Recommendation Algorithm \- GitHub, acceso: junio 8, 2025, [https://github.com/twitter/the-algorithm](https://github.com/twitter/the-algorithm)  
2. Cracking the Code: How the Twitter Algorithm Works \- Tweet Hunter, acceso: junio 8, 2025, [https://tweethunter.io/blog/twitter-algorithm-full-analysis](https://tweethunter.io/blog/twitter-algorithm-full-analysis)  
3. Designing Twitter's Scalable System, acceso: junio 8, 2025, [https://abhisekroy.hashnode.dev/twitter-system-design](https://abhisekroy.hashnode.dev/twitter-system-design)  
4. The Architecture Twitter Uses to Deal with 150M Active Users, 300K QPS, a 22 MB/S Firehose, and Send Tweets in Under 5 Seconds \- High Scalability, acceso: junio 8, 2025, [https://highscalability.com/the-architecture-twitter-uses-to-deal-with-150m-active-users/](https://highscalability.com/the-architecture-twitter-uses-to-deal-with-150m-active-users/)  
5. the-algorithm/home-mixer/README.md at main · twitter/the-algorithm \- GitHub, acceso: junio 8, 2025, [https://github.com/twitter/the-algorithm/blob/main/home-mixer/README.md](https://github.com/twitter/the-algorithm/blob/main/home-mixer/README.md)  
6. Twitter's Recommendation Algorithm: An In-Depth Overview | Talent500 blog, acceso: junio 8, 2025, [https://talent500.com/blog/twitters-recommendation-algorithm-an-in-depth-overview/](https://talent500.com/blog/twitters-recommendation-algorithm-an-in-depth-overview/)  
7. Twitter Publishes its Tweet Ranking Algorithm Data on GitHub, Providing More Transparency in Process | Social Media Today, acceso: junio 8, 2025, [https://www.socialmediatoday.com/news/twitter-publishes-its-tweet-ranking-algorithm-data-on-github-providing-mor/646581/](https://www.socialmediatoday.com/news/twitter-publishes-its-tweet-ranking-algorithm-data-on-github-providing-mor/646581/)  
8. igorbrigadir/awesome-twitter-algo: The release of the Twitter algorithm, annotated for recsys \- GitHub, acceso: junio 8, 2025, [https://github.com/igorbrigadir/awesome-twitter-algo](https://github.com/igorbrigadir/awesome-twitter-algo)  
9. the-algorithm/navi/README.md at main · twitter/the-algorithm \- GitHub, acceso: junio 8, 2025, [https://github.com/twitter/the-algorithm/blob/main/navi/README.md](https://github.com/twitter/the-algorithm/blob/main/navi/README.md)  
10. Why Rust, acceso: junio 8, 2025, [https://book.gist.rs/hello/why-rust.html](https://book.gist.rs/hello/why-rust.html)  
11. Low-Level Design of Twitter: Architecture, Tweet Processing, and Scalability, acceso: junio 8, 2025, [https://getsdeready.com/low-level-design-of-twitter-how-tweets-are-processed-and-delivered/](https://getsdeready.com/low-level-design-of-twitter-how-tweets-are-processed-and-delivered/)  
12. How can you handle scalability issues in recommender systems? \- Milvus, acceso: junio 8, 2025, [https://milvus.io/ai-quick-reference/how-can-you-handle-scalability-issues-in-recommender-systems](https://milvus.io/ai-quick-reference/how-can-you-handle-scalability-issues-in-recommender-systems)  
13. Unified User Actions (UUA) \- twitter/the-algorithm · GitHub, acceso: junio 8, 2025, [https://github.com/twitter/the-algorithm/blob/main/unified\_user\_actions/README.md](https://github.com/twitter/the-algorithm/blob/main/unified_user_actions/README.md)  
14. How Does the Twitter (X) Algorithm Work in 2025? \- Fourthwall, acceso: junio 8, 2025, [https://fourthwall.com/blog/how-does-twitter-x-algorithm-work](https://fourthwall.com/blog/how-does-twitter-x-algorithm-work)  
15. How Does The Twitter Algorithm Work? 10 Tips \- SocialPilot, acceso: junio 8, 2025, [https://www.socialpilot.co/blog/twitter-algorithm](https://www.socialpilot.co/blog/twitter-algorithm)  
16. Analysis of Twitter the-algorithm source code with LangChain, GPT4 and Deep Lake, acceso: junio 8, 2025, [https://python.langchain.com.cn/docs/use\_cases/code/twitter-the-algorithm-analysis-deeplake](https://python.langchain.com.cn/docs/use_cases/code/twitter-the-algorithm-analysis-deeplake)  
17. the-algorithm/timelines/data\_processing/ml\_util/aggregation\_framework/README.md at main \- GitHub, acceso: junio 8, 2025, [https://github.com/twitter/the-algorithm/blob/main/timelines/data\_processing/ml\_util/aggregation\_framework/README.md](https://github.com/twitter/the-algorithm/blob/main/timelines/data_processing/ml_util/aggregation_framework/README.md)  
18. Real-Time Data Ingestion Architecture: Tools & Examples | Estuary, acceso: junio 8, 2025, [https://estuary.dev/blog/real-time-data-ingestion/](https://estuary.dev/blog/real-time-data-ingestion/)  
19. Kafka and Airflow Implementation at Twitter \- Anant, acceso: junio 8, 2025, [https://anant.us/blog/kafka-airflow-pipelines-twitter/](https://anant.us/blog/kafka-airflow-pipelines-twitter/)  
20. Understanding the X Algorithm \- Tweet Hunter, acceso: junio 8, 2025, [https://tweethunter.io/blog/understanding-the-x-algorithm](https://tweethunter.io/blog/understanding-the-x-algorithm)  
21. What can we learn from 'The Algorithm,' Twitter's partial open-sourcing of it's feed-ranking recommendation system? | Sol Messing, acceso: junio 8, 2025, [https://solomonmg.github.io/post/twitter-the-algorithm/](https://solomonmg.github.io/post/twitter-the-algorithm/)  
22. How the Twitter Algorithm Works in 2025 \[+6 Strategies\] | Sprout Social, acceso: junio 8, 2025, [https://sproutsocial.com/insights/twitter-algorithm/](https://sproutsocial.com/insights/twitter-algorithm/)  
23. How To Master The X Algorithm In 2025? \- Socinator, acceso: junio 8, 2025, [https://socinator.com/blog/master-x-algorithm/](https://socinator.com/blog/master-x-algorithm/)  
24. How the ????/Twitter Algorithm Works \- Hypefury, acceso: junio 8, 2025, [https://hypefury.com/blog/en/how-the-x-twitter-algorithm-works/](https://hypefury.com/blog/en/how-the-x-twitter-algorithm-works/)  
25. A Comprehensive Guide to the X Algorithm: How It Works in 2025 \- Brandwatch, acceso: junio 8, 2025, [https://www.brandwatch.com/blog/x-algorithm/](https://www.brandwatch.com/blog/x-algorithm/)  
26. How The Twitter Algorithm Works: Complete Guide For 2025 \- RecurPost, acceso: junio 8, 2025, [https://recurpost.com/blog/twitter-algorithm/](https://recurpost.com/blog/twitter-algorithm/)  
27. Understanding Twitter's Algorithm: Key Insights \- Kolsquare, acceso: junio 8, 2025, [https://www.kolsquare.com/en/blog/learn-the-keys-to-understanding-twitters-algorithm](https://www.kolsquare.com/en/blog/learn-the-keys-to-understanding-twitters-algorithm)  
28. Twitter's algorithm ranking factors: A definitive guide \- Search Engine Land, acceso: junio 8, 2025, [https://searchengineland.com/twitter-algorithm-ranking-factors-386215](https://searchengineland.com/twitter-algorithm-ranking-factors-386215)  
29. Understanding How the X (Twitter) Algorithm Works in 2025 \- SocialBee, acceso: junio 8, 2025, [https://socialbee.com/blog/twitter-algorithm/](https://socialbee.com/blog/twitter-algorithm/)  
30. How to Use the X Algorithm to Your Marketing Advantage, acceso: junio 8, 2025, [https://digitalmarketinginstitute.com/blog/how-to-use-twitter-algorithm-to-your-marketing-advantage](https://digitalmarketinginstitute.com/blog/how-to-use-twitter-algorithm-to-your-marketing-advantage)  
31. the-algorithm/src/scala/com/twitter/interaction\_graph/README.md at main \- GitHub, acceso: junio 8, 2025, [https://github.com/twitter/the-algorithm/blob/main/src/scala/com/twitter/interaction\_graph/README.md](https://github.com/twitter/the-algorithm/blob/main/src/scala/com/twitter/interaction_graph/README.md)  
32. RealGraph: User Interaction Prediction at Twitter, acceso: junio 8, 2025, [https://www.ueo-workshop.com/wp-content/uploads/2014/04/sig-alternate.pdf](https://www.ueo-workshop.com/wp-content/uploads/2014/04/sig-alternate.pdf)  
33. the-algorithm/src/scala/com/twitter/simclusters\_v2/README.md at main \- GitHub, acceso: junio 8, 2025, [https://github.com/twitter/the-algorithm/blob/main/src/scala/com/twitter/simclusters\_v2/README.md](https://github.com/twitter/the-algorithm/blob/main/src/scala/com/twitter/simclusters_v2/README.md)  
34. TwHIN-BERT: A Socially-Enriched Pre-trained Language Model for Multilingual Tweet Representations at Twitter \- Ahmed El-Kishky, acceso: junio 8, 2025, [https://ahelk.github.io/papers/elkishky\_twhinbert.pdf](https://ahelk.github.io/papers/elkishky_twhinbert.pdf)  
35. the-algorithm/src/scala/com/twitter/graph/batch/job/tweepcred/README at main \- GitHub, acceso: junio 8, 2025, [https://github.com/twitter/the-algorithm/blob/main/src/scala/com/twitter/graph/batch/job/tweepcred/README](https://github.com/twitter/the-algorithm/blob/main/src/scala/com/twitter/graph/batch/job/tweepcred/README)  
36. the-algorithm/trust\_and\_safety\_models/README.md at main \- GitHub, acceso: junio 8, 2025, [https://github.com/twitter/the-algorithm/blob/main/trust\_and\_safety\_models/README.md](https://github.com/twitter/the-algorithm/blob/main/trust_and_safety_models/README.md)  
37. Twitter exec says it's moving fast on moderation as harmful content surges, acceso: junio 8, 2025, [https://www.straitstimes.com/world/united-states/twitter-exec-says-moving-fast-on-moderation-as-harmful-content-surges](https://www.straitstimes.com/world/united-states/twitter-exec-says-moving-fast-on-moderation-as-harmful-content-surges)  
38. How Twitter Built a Massive Machine Learning Pipeline Using Kafka \- Confluent, acceso: junio 8, 2025, [https://www.confluent.io/blog/how-twitter-built-a-machine-learning-pipeline-with-kafka/](https://www.confluent.io/blog/how-twitter-built-a-machine-learning-pipeline-with-kafka/)  
39. real-time data processing with storm: using twitter streaming \- ijesrt, acceso: junio 8, 2025, [https://www.ijesrt.com/Old\_IJESRT/issues%20pdf%20file/Archive-2017/July-2017/2.pdf](https://www.ijesrt.com/Old_IJESRT/issues%20pdf%20file/Archive-2017/July-2017/2.pdf)  
40. Real Time Twitter Analytics with Apache Storm \- ResearchGate, acceso: junio 8, 2025, [https://www.researchgate.net/publication/381793696\_Real\_Time\_Twitter\_Analytics\_with\_Apache\_Storm](https://www.researchgate.net/publication/381793696_Real_Time_Twitter_Analytics_with_Apache_Storm)  
41. Twitter's Manhattan: A Real-time, Multi-tenant Distributed Database \- InfoQ, acceso: junio 8, 2025, [https://www.infoq.com/news/2014/05/twitters-manhattan/](https://www.infoq.com/news/2014/05/twitters-manhattan/)  
42. Providing Flexible Database Consistency Levels with Manhattan at Twitter • Boaz Avital • GOTO 2016 \- YouTube, acceso: junio 8, 2025, [https://www.youtube.com/watch?v=gvdXBC-NReQ](https://www.youtube.com/watch?v=gvdXBC-NReQ)  
43. Twitter/X KPIs \- Fanpage Karma Insights, acceso: junio 8, 2025, [https://www.fanpagekarma.com/insights/twitter-x-kpis/](https://www.fanpagekarma.com/insights/twitter-x-kpis/)  
44. Metrics That Matter—Your Guide to Twitter User Engagement \- SocialSellinator, acceso: junio 8, 2025, [https://www.socialsellinator.com/social-selling-blog/twitter-user-engagement-metrics](https://www.socialsellinator.com/social-selling-blog/twitter-user-engagement-metrics)  
45. Twitter Engagement Metric \- Klipfolio, acceso: junio 8, 2025, [https://www.klipfolio.com/resources/kpi-examples/social-media/twitter-engagement-metrics](https://www.klipfolio.com/resources/kpi-examples/social-media/twitter-engagement-metrics)  
46. 7 Important X (formerly Twitter) Analytics Metrics for Marketing Agencies \- Swydo, acceso: junio 8, 2025, [https://www.swydo.com/blog/x-analytics-metrics/](https://www.swydo.com/blog/x-analytics-metrics/)  
47. Design Twitter: A Comprehensive Guide \- System Design School, acceso: junio 8, 2025, [https://systemdesignschool.io/problems/twitter/solution](https://systemdesignschool.io/problems/twitter/solution)  
48. Tweet Like Pro: 7 Hacks to Optimize Content for Twitter Algorithm \- Tagembed, acceso: junio 8, 2025, [https://tagembed.com/blog/twitter-algorithm/](https://tagembed.com/blog/twitter-algorithm/)  
49. How to Use the New Twitter Dashboard For A/B Testing \- Online Marketing Institute, acceso: junio 8, 2025, [https://www.onlinemarketinginstitute.org/blog/2016/10/original-use-new-twitter-dashboard-ab-testing/](https://www.onlinemarketinginstitute.org/blog/2016/10/original-use-new-twitter-dashboard-ab-testing/)  
50. Engagement, user satisfaction, and the amplification of divisive content on social media | PNAS Nexus | Oxford Academic, acceso: junio 8, 2025, [https://academic.oup.com/pnasnexus/article/4/3/pgaf062/8052060](https://academic.oup.com/pnasnexus/article/4/3/pgaf062/8052060)  
51. (PDF) Evaluating Twitter's algorithmic amplification of low-credibility content: an observational study \- ResearchGate, acceso: junio 8, 2025, [https://www.researchgate.net/publication/378808348\_Evaluating\_Twitter's\_algorithmic\_amplification\_of\_low-credibility\_content\_an\_observational\_study](https://www.researchgate.net/publication/378808348_Evaluating_Twitter's_algorithmic_amplification_of_low-credibility_content_an_observational_study)
